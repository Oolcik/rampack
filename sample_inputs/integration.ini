# This is an example INI input file for the `casino' mode specifying a whole NpT gas-liquid-solid simulation sequence
# for hard spheres. The user is encouraged to read the documentation carefully and run this test file to see how it
# works in practice.
#
# This file contains the general instruction for input files and most information are here. Additional sample input
# file overlap_reduction.ini provides additional information on overlap reduction run type.

########## HOW TO READ THE INSTRUCTION ##########

# Each parameter is described below. For a visual aid, all syntax element (parameters, their values and format) are
# written within double-quotes "...". Each parameter follows its own syntax - it could be for example three numbers
# separated by spaces, which will be denoted as "[number 1] [number 2] [number 3]". Each required parameter token is
# marked by square brackets "[...]" and explained, and the optional tokens are marked with round brackets "(...)".
# Tokens written without any brackets are literals. Each parameter may have multiple variants with a different syntax.
# They are presented using numbered lists "1.", "2.", ... . Some have sub-variants, which are enumerated using
# sub-lists, eg. "4.1.", "4.2.", ...


########## THE GENERAL SECTION ##########

# The file starts with the general section (which is anonymous INI section) specifying common parameters such as the
# molecule's shape, interaction type, etc. as well as the initial configuration, while subsequent sections named
# "\[[run_type].[run_name]\]" (where \[ and \] are literal square brackets) describe runs that will be performed
# sequentially one by one. "[run_type]" should be "integration" for NpT runs and "overlaps" for overlap reduction.
# "[run_name]" is a user-defined name of the run (may be for example "gas", "liquid" and "crystal" as in this exemplary
# input file). The final snapshot of one run is the starting point for the next one. The initial configuration for the
# first run is configured using "initialDimensions", "initialArrangement" and "numOrParticles" parameters in this
# section.

# Below is the full list of general parameters with a detailed description of each.

# Initial dimensions of the orthorhombic simulation box. Supported variants:
# 1. "[side length]"
#    cubic box with a given side length
# 2. "[x length] [y length] [z length]"
#    explicit box side lengths of a cuboidal cell
# 3. "[1st side x] [... y] [... z] [2nd side x] [... y] [... z] [3rd side x] [... y] [... z]"
#    explicit coordinates of triclinic box vectors
# 4. "auto"
#    box size will be calculated automatically based on cell size from "initialArrangement"
initialDimensions = 100 100 100

# Initial arrangement. It is generated first by creating a lattice of a specific type, then some lattice transformations
# may be applied. At the end, a way of choosing unoccupied spots (if a number of particles is smaller than the number of
# slots available) may be given. General syntax:
#
# "[cell specification]" | "[transformation 1]" | ... | "[transformation n]" | "[population scheme]"
#
# Optional transformations can be stacked together and are separated using a pipe "|". Population scheme is also
# optional (implicit behaviour is equivalent to "populate serial xyz" - see below).
#
# "[cell specification]" specifies the type of a unit cell and a number of those cells. Variants:
# 1. "[cell specification]" := "[cell type] default"
#    create n x n x n (where n is chosen automatically) lattice just large enough to accommodate all particles.
#    "initialDimensions" cannot be "auto" in this variant - cell dimensions are inferred from the box size.
# 2. "[cell specification]" := "[cell type] ncell [nx] [ny] [nz]"
#    number of cells is specified explicitly. Cell dimensions are calculated based on the box size (thus is cannot be
#    "auto" in this case)
# 3. "[cell specification]" := "[cell type] ncell [nx] [ny] [nz] dim [cell dim]"
#    both number of cells ("[nx] [ny] [nz]") and cell dimensions ("[cell dim]") are specified explicitly. Box dimensions
#    have to be "auto" - they are calculated based on lattice dimensions. "[cell dim]" can be:
#    3.1 "[cell dim]" := "[linear size]"
#    3.2 "[cell dim]" := "[x length] [y length] [z length]"
#    3.3 "[cell dim]" := "[1st side x] [... y] [... z] [2nd side x] [... y] [... z] [3rd side x] [... y] [... z]"
#    Variants 3.2 and 3.3 have identical meaning as variants 2. and 3. of "initialDimensions". Variant 3.1 is more
#    subtle and depends on "[cell type]" (see below). For cubic types "sc", "bcc", "fcc" and "custom" type the cell is
#    then cubic and "[linear size]" is the side length of the cube. For hexagonal types "hcp", "hexagonal" this variant
#    DOES NOT produce a cubic cell, but a cuboidal one with such dimensions that spheres with appropriate radius placed
#    in this cell would be tangent (which would not be possible in a cubic cell). The specific dimensions are described
#    below in "[cell type]" specification.
#
# "[cell type]" specifies how many molecules are in the cell and where they are placed. Note that it does not force
# the shape of the cell, but only the number and placement of molecules withing the cell (the shape is controlled by the
# "ncell" and "dim" arguments from "[cell specification]" as well as simulation box dimensions - see above). Supported
# variants:
# 1. "sc"
#    Simple cubic (a single particle in the middle)
# 2. "bcc"
#    Body centred cubic (positions relative to cell: {0.25, 0.25, 0.25}, {0.75, 0.75, 0.75})
# 3. "fcc"
#    Face centred cubic (positions relative to cell: {0.25, 0.25, 0.25}, {0.25, 0.75, 0.75}, {0.75, 0.25, 0.75},
#    {0.75, 0.75, 0.25})
# 4. "hcp axis [ax]"
#    Hexagonal close packed. "[ax]" specifies orientation of the cell - it is the direction orthogonal to hexagonal
#    honeycombs. Relative positions for "[ax]" = "z" are: {1/4, 1/12, 1/4}, {3/4, 7/12, 1/4}, {1/4, 5/12, 3/4},
#    {3/4, 11/12, 3/4}. Variant 3.1 of "[cell dim]" specifying linear size L (for "[ax]" = "z") produces cuboidal cell
#    of size {L, sqrt(3)*L, 2*sqrt(6)*L/3}. For "[ax]" = "x", "y" everything is permuted cyclically.
# 5. "hexagonal axis [ax]"
#    Hexagonal cell. "[ax]" specifies orientation of the cell - it is the direction orthogonal to hexagonal honeycombs,
#    stacked along it (without any alternation as for hcp lattice). Relative positions for "[ax]" = "z" are:
#    {1/4, 1/4, 1/2}, {3/4, 3/4, 1/2}. Variant 3.1 of "[cell dim]" specifying linear size L (for "[ax]" = "z") produces
#    cuboidal cell of size {L, sqrt(3)*L, L}. For "[ax]" = "x", "y" everything is permuted cyclically.
# 6. "custom shapes [shape 1] , ... , [shape n]"
#    Custom unit cell with arbitrary shape positions and orientation. Shapes are separated using commas ",".
#    "[shape]" has 2 variants:
#    6.1. "[shape]" := "[pos x] [pos y] [pos z]"
#         Specifies default-oriented shape with a given position as relative coordinates within the cell (in the range
#         [0, 1))
#    6.2. "[shape]" := "[pos x] [pos y] [pos z] [rot x] [rot y] [rot z]"
#         Specifies a shape with a given position as relative coordinates within the cell (in the range [0, 1)) and with
#         orientation specified by angles of rotations (in degrees) around z, y and x axes (in this order)
#
# All keywords in "[cell specification]": "ncell", "dim", "default", "axis", "shapes" may appear in an arbitrary order
# (possibly different then the one presented in the specification). For example "hcp axis x ncell 5 10 15 dim 2" is the
# same as "hcp dim 2 ncell 5 10 15 axis x".
#
# "[transformation]" specifies an optional transformation of a lattice (which can be stacked together). Available
# transformations:
# 1. "optimizeCell [spacing] [axis order]"
#    Optimization of cell dimensions. It maximally shrinks the lattice (axis by axis, in an order given by
#    "[axis order]") without introducing overlaps in directions of lattice vectors (so that the angles remain
#    unchanged). Afterwards, it expands the lattice by "[spacing]" in the directions of CELL HEIGHTS (not lattice
#    vectors, however the two are the same for cubic/cuboidal cells), also preserving the angles.
# 2. "optimizeLayers [spacing] [layer axis]"
#    Optimization of the distances between particles and cell dimensions in a direction given by "[layer axis]", in a
#    layer-wise fashion. First, it identifies layers and makes them tangent (first making 1st and 2nd layer tangent,
#    then 2nd and 3rd, etc). Then, it optimizes cell dimension so that layers of adjacent cells are tangent. Afterwards,
#    it introduces a spacing "[spacing]" between all layers in the directions of CELL HEIGHTS (not lattice vectors,
#    however the two are the same for cubic/cuboidal cells). Box angles are preserved in the whole procedure.
# 3. "columnar [column axis] [rng seed]"
#    Creates a columnar phase from the lattice - it identifies columns along axis "[column axis]" (using relative cell
#    coordinates) and translates them by a random amount in columns' direction (along a lattice vector). "[rng seed]"
#    specifies a seed of a random number generator used to sample random translations. Works only for periodic lattices.
# 4. "randomizeFlip [rnd seed]"
#    With a probability 1/2, it rotates each molecule by 180 degrees around a secondary axis placed in a geometric
#    origin. Therefore, on average, half of the particles will be "flipped".
# 5. "layerRotate [layer axis] [rot. axis] [rot. angle] (alternating)"
#    It identifies layers in the lattice in "[layer axis]" direction and rotates particles by "[rot. angle]" degrees
#    around "[rot. axis]" axis. If "alternating" is specified, molecules within even layers will be rotated
#    counter-clockwise and in odd layers - clockwise. If only one layer is identified within a unit cell (for example in
#    a sc lattice), 2 unit cells will be joined (the same is true for any odd number of layers in a unit cell). Works
#    only for periodic lattices. If "alternating" is not specified, all molecules are rotated by a same angle,
#    counter-clockwise.
#
# "[population scheme]" describes how lattice should be filled with particles (if their number is smaller than the
# number of slots in the lattice). Variants:
# 1. "[population scheme]" := "populate serial ([axis order])"
#    Populates the lattice cell by cell looping through cell indices. The order of loops is given, from outermost to
#    innermost, by "[axis order]". For example, for "[axis order]" = "yxz", first z column is filled, then zx plane is
#    filled with those columns, and lastly those planes are stacked in y direction. Within a cell, molecules are placed
#    in the order in which they appear within the cell. Default values of "[axis order]" is "xyz".
# 2. "[population scheme]" := "random [rng seed]"
#    Molecules are placed at random using RNG sequence seeded with "[rng seed]". However, their order is not completely
#    random - particles with close indices will have relatively close real-space positions (for a better cache
#    performance).
#
# Here are a few of examples of initial configurations which can be created:
# 1. "initialDimensions = 10"
#    "initialArrangement = sc default"
#    "numOfParticles = 1000"
#    Create a simple cubic lattice of 10 x 10 x 10 cells, where the cells are cubes of size 1 x 1 x 1
# 2. "initialDimensions = 100"
#    "initialArrangement = sc ncell 5 10 20 | optimizeCell 0.1 xyz | populate random"
#    "numOfParticles = 500"
#    Create a simple cubic lattice of 5 x 10 x 20 cells, optimize particle distance to 0.1 in each direction and then
#    populate half of slots with molecules at random.
# 3. "initialDimensions = auto"
#    "initialArrangement = hcp ncell 2 10 10 dim 10 | layerRotate x y 30 alternating | optimizeCell 0.1 yzx"
#    Create a hcp lattice, perform alternating rotation around y axis by 30 degrees, of layers along x axis (there are
#    2 hcp cells in this direction, so 4 layers altogether) and then shrink the cell size first optimizing distances
#    within the layers and then the distances between the layers. The resulting structure is anticlinic crystal I
#    (hexagonal order within a layer and alternating layer tilt)
# 4. "initialDimensions = auto"
#    "initialArrangement = hexagonal ncell 4 10 10 dim 10 | optimizeCell 0.1 yzx | columnar x 1234 | randomizeFlip 1234"
#    Creates hexagonal lattice, optimizes cell size, makes the cell columnar along x axis and randomizes flips. All RNG
#    seeds were equal 1234. The resulting phase is Col_h phase along x axis with random flips.
initialArrangement = sc default

# If specified, walls will be created on both opposite box faces intersected by specified axes. For example, using
# "xy" in a cubic box with side length L creates walls described by equations: x=0, x=L, y=0 and y=L. Leaving the field
# empty or skipping it leaves the simulation box without any walls. Please note that placing a wall does not turn off
# the scaling in this direction. If one intends so, it has to be done manually when specifying "scalingType" (see
# below).
walls =

# The number of molecules to be simulated
numOfParticles = 1000

# Comma-separated list of molecule move types that should be performed during the run. Given the number of molecules in
# the system, each move type declares how many moves should be performed. Move type is sampled at random so that during
# each cycles the average number of moves of a given type matches the declaration. Most move types support dynamic
# changes of step sizes to reach target acceptance rate. Supported move type are as follows:
# 1. "translation [initial step size] ([max step size])"
#    Performs a translation for a randomly selected molecule. Each translation coordinate is independently selected
#    from a uniform interval [-"[step size]", "[step size]"] ("[step size]" is initialized from "[initial step size]").
#    If specified, "[step size]" is capped from above by "[max step size]". In a single cycle each particle is perturbed
#    on average once.
# 2. "rotation [initial angle]"
#    Performs a rotation of a randomly selected molecule. Rotation is done around a random axis by an angle sampled
#    uniformly from an interval [-"[angle]", "[angle]"] ("[angle]" is initialized from "[initial angle]"). In a single
#    cycle each particle is perturbed on average once.
# 3. "rototranlslation [initial step size] [initial angle] ([max step size])"
#    Performs simultaneous translation and rotation of a randomly selected molecule. The way of sampling and parameter
#    names are the same as for "translation" and "rotation" moves. Both: translation and rotation step sizes are always
#    adjusted simultaneously by the same factor, so they ratio stays constant. The ratio can be selected heuristically
#    by benchmarking, or using a rule of thumb: maximal rotation should move the furthest part of the particle by the
#    same amount as the maximal translation.
# 4. "flip ([flip every])"
#    Performs a rotation by 180 degrees of a random particle around its secondary axis. During one cycle
#    1 / "[flip every]" fraction of particles is flipped (if not specified, "[flip every]" defaults to 10).
moveTypes = translation 10

# Type of the scaling. Notice that some types allow independent moves for some or all sides which facilitate relaxation
# of the diagonal part of stress tensor (directional pressures) or even full triclinic relaxation of sheer pressure.
# If "scalingType" is variant 1.-3. and the box is triclinic, scaling is performed height-wise, ie. face angles remain
# unaltered. Alternatives for "scalingType":
# 1. "delta V"
#    The ratio of all box heights remains constant while the volume is changed by an amount sampled from
#    [-"volumeStepSize", "volumeStepSize"] interval uniformly
#
# 2. "(independent) [scaling distribution] [direction specification]"
#    Generalized scaling, where one can customize type of the scaling, which directions should be scaled, which should
#    be coupled, whether scaling is performed in one direction per move or all together, etc.
#
#    "[scaling distribution]" can be one of:
#    2.1.1. "linear"
#           Linear scaling is achieved by sampling uniformly a random number from [-"volumeStepSize", "volumeStepSize"]
#           interval and changing appropriate box heights by this amount.
#    2.1.2. "log"
#           Logarithmic scaling is achieved by sampling uniformly a random number "w" from
#           [-"volumeStepSize", "volumeStepSize"] interval and multiplying appropriate box heights by a factor exp(w).
#
#    "[direction specification]" describes direction ("x", "y" and "z") in which scaling should be performed in
#    accordance to "[scaling distribution]". By default, all directions are uncoupled, so using "xyz" gives fully
#    anisotropic scaling where all directions are scaled independently. Coupling is achieved by surrounding coupled
#    directions by parentheses "(...)". For example "(zx)y" makes "y" independent direction, while "x" and "z" are
#    scaled together. One or more directions can be blocked by surrounding them with square brackets "[...]". For
#    example "xy[z]" specifies uncoupled scaling of "x" and "y" directions and "z" remains unaltered. Please note that
#    the behaviour of all directions has to be given explicitly, thus, for example "(xy)" is malformed, since "z" is
#    missing. Apart from generalized syntax with "x", "y", "z", "(...)" and "[...]", a few expressive shortcuts are
#    available:
#    2.2.1. "isotropic"        => equivalent to "(xyz)"
#    2.2.2. "anisotropic x"    => equivalent to "x(yz)"
#    2.2.3. "anisotropic y"    => equivalent to "y(zx)"
#    2.2.4. "anisotropic z"    => equivalent to "z(xy)"
#    2.2.5. "anisotropic xyz"  => equivalent to "xyz"
#
#    "independent" is an optional switch. By default, scaling is performed in all directions at once. For example, for
#    "(xy)z" one scaling factor is sampled for "x" and "y" directions and a different, independent one is sampled for
#    "z" direction, however scaling in all directions is performed at once. If "independent" is included, only one
#    uncoupled direction is selected at random during volume move. Staying with "(xy)z" example, either both "x" and "y"
#    will be scaled in a coupled manner and "z" unscaled, or "x" and "y" unaltered, and "z" scaled.
#
# 3. "(independent) delta triclinic"
#    Box side vectors are translated by random vectors with coordinates sampled uniformly from
#    [-"volumeStepSize", "volumeStepSize"] interval. This scaling types enables to perform simulations in
#    isobaric-isotension ensemble (relaxing off-diagonal parts of stress tensor). If "independent" is specified, only a
#    single, randomly sample side will be perturbed. Otherwise, all are perturbed at once.
scalingType = delta V

# The maximal size of the volume move. Its meaning is dependent on scaling type. Please refer to "scalingType" above.
volumeStepSize = 1000

# The seed for random number generator
seed = 1234

# The shape of the molecule. It is specified by "shapeName", while its (shape-dependent) parameters, such as eg. the
# axis ratio are given by "shapeAttributes". Each shape may support one ore more interaction types. A full list of
# shapes, together with their attributes and interactions is given below. "shapeName" is presented together with
# "shapeAttributes" in the format "[shape name] (shape attributes)". For each list entry (a single shape) all supported
# interaction are shown as a sublist.
# 1. "Sphere [radius]"
#    sphere with a radius "[radius]". Supported interaction types:
#    1.1. "hard"
#         hard-core interaction
#    1.2. "lj [epsilon] [sigma]"
#         Lennard-Jones interaction with a standard definition of "[epsilon]" and "[sigma]" parameters:
#         LJ(r) = 4 epsilon ((sigma/r)^12 - (sigma/r)^6)
#         r is the distance between interaction centers
#    1.3. "repulsive_lj [epsilon] [sigma]"
#         Lennard-Jones, but only the repulsive part - the so-called Weeks-Chandler-Anderson potential:
#         LJ(r) + epsilon   for r < 2^(1/6),
#         0                 for r >= 2^(1/6).
#    1.4. "square_inverse_core [epsilon] [sigma]"
#         short-ranged attractive or repulsive interaction, resembling screened dipolar interaction, defined as:
#         epsilon ((sigma/r)^2 - 1)   for r < sigma,
#         0                           for r >= sigma.
# 2. "Spherocylinder [length] [radius]"
#    spherocylinder with cap radius "[radius]" (or, equivalently, half-width) and the distance between cap centers
#    "[length]". For the default orientation, "Spherocylinder" is aligned with x axis. Supported interactions:
#    2.1. "hard"
#         hard-core interaction
# 3. "KMer [number of spheres] [radius] [distance]"
#    a linear chain of "[number of spheres]" spheres with radius "[radius]". The centers are equally spaced with a
#    distance "[distance]". Supported interactions:
#    ---- same as for "Sphere", however each pair of beads is treated separately
# 4. "PolysphereBanana [arc radius] [arc angle] [number of spheres] [sphere radius]"
#    chain of "[number of spheres]" spheres with radius "[sphere radius]" placed on an arc (banana-shaped). The arc is
#    defined by its radius "[arc radius]" and arc angle "[arc angle]". The centres of spheres are equidistantly placed
#    on the arc and its endpoints are at the same time the centres of outermost spheres. The centers of spheres in
#    "PolysphereBanana" molecule with a default orientation lie within xy plane, the main axis (joining the ends of the
#    arc) is y axis and the arc is bent towards the negative x semi-axis (the vector joining either endpoint and the
#    middle has a negative x component). Supported interactions:
#    ---- same as for "Sphere", however each pair of beads is treated separately
# 5. "PolysphereLollipop [num of spheres] [small radius] [large radius] [small penetration] [large penetration]"
#    linear chain of "[num of spheres]" spheres, where a single sphere at the end has different size than the rest of
#    them (usually larger). "[small radius]" and "[large radius]" are radii of, respectively, all apart from the last,
#    and the last sphere. Similarly, "[small penetration]" and "[large penetration]" describe how much spheres overlap.
#    In particular, 0 means that the spheres are tangent.
#    ---- same as for "Sphere", however each pair of beads is treated separately
# 6. "PolysphereWedge [num of spheres] [small radius] [large radius] [penetration]"
#    linear chain of "[num of spheres]" spheres, where radii of spheres are increased linearly. "[small radius]" and
#    "[large radius]" are radii of, respectively, the first and the last sphere (usually the last one is larger).
#    "[penetration]" describes how much spheres overlap. In particular, 0 means that the spheres are tangent.
#    ---- same as for "Sphere", however each pair of beads is treated separately
# 7. "PolyspherocylinderBanana [arc radius] [arc angle] [number of segments] [radius] ([subdivisions])"
#    a molecule similarly shaped as "PolysphereBanana", but using spherocylinders. "[arc radius]" and "[arc angle]" have
#    identical meaning as in "PolysphereBanana", "[radius]" is the radius of spherocylinders' caps (equivalently their
#    half-width). "[number of segments]" is a number of spherocylinders used to approximate the arc - the arc is divided
#    into that many segments and spherocylinders are placed around them. The default orientation is analogous to
#    "PolysphereBanana". If the optional parameter "[subdivisions]" is specified, each spherocylinder is divided into
#    that many parts - it does not change the physics, but may increase the speed of the simulation. Default value is 1
#    (no divisions). Supported interactions:
#    6.1. "hard"
#         hard-core repulsion of each pair of spherocylinders
shapeName = Sphere
shapeAttributes = 0.5
interaction = hard

# Number of parallel threads used to perform volume moves
scalingThreads = 4

# The parallelization of molecule moves is done using the domain division - the space is divided into cuboidal subspaces
# with inactive (ghost) layers between them. This parameter specifies how many divisions should be made in each
# direction. Each domain is then assigned to a separate thread. As a result, the number of threads is the product of the
# number of divisions in each direction. Format:
# "[number of divisions in x direction] [... y ...] [... z ...]"
# Optimally one should use the same number of threads for both volume and molecule moves. A lower number of scaling
# threads than molecule threads is forbidden. Then "1 1 1" is given, domain division will be deactivated.
domainDivisions = 2 2 1

# If true, the current run will be stored, when SIGINT or SIGTERM is received. It means that all specified output files
# will be produced. The run can be continued later using the standard --continue option. If false, the run will be
# permanently lost.
saveOnSignal = true


########## RUNS AND RUN SPECIFIC PARAMETERS ##########

# In this exemplary input file there are three integration runs with names: "gas", "liquid" and "solid". Example overlap
# reduction run is in another sample input file - "overlap_reduction.ini". Each run has a set of its own parameters such
# as temperature, pressure, observables to be calculated, etc. The integration starts with thermalization phase in which
# the system should reach its equilibrium state. After that, the averaging phase follows, when ensemble averages of the
# observables are computed. During averaging phase the auto-adjustment of molecule an volume move amplitudes is turned
# off. After the finished run ensemble averages of observables are printed on the standard output.
# Moreover one can request to output the following auxiliary data:
# 1. internal representation of the packing
# 2. Wolfram Mathematica notebook with the visualisation of the final snapshot
# 3. output file with ensemble averages (the same ones as are printed on the standard output by default)
# 4. instantaneous values of the observables every N cycles
# The observables to compute are specified using "observables" parameter.

# Each integration run is an INI section with the format "\[integration.[run name]\]" - "[run name]" is user-specified
# unique name of the run
[integration.gas]

# Temperature in k_B units. The temperature can be just a floating-point constant, or a dynamic parameter, which changes
# based on a current simulation cycles. Available dynamic parameters:
# 1. const [value]
#    A constant parameter, which always has the same value. It is exactly the same as just passing a single number.
# 2. linear [initial value] [slope]
#    If current cycle is "[current cycle]", the value is calculated as "[initial value]" + "[slope]" * "[current cycle]"
# 3. exp [initial value] [rate]
#    If current cycle is "[current cycle]", the value is calculated as
#    [initial value]" * exp("[rate]" * "[current cycle]")
# 4. piecewise [cycle 1] [parameter 1] , [cycle 2] [parameter 2] , ...
#    A piecewise combination of dynamic parameters. The parameters are separated by commas. First, the number of cycle
#    "[cycle ...]" is given when the specific parameter should start, and then parameter specification
#    "[parameter ...]", (as in 1. - 3.). "[cycle 1]" has to be equal 0 and subsequent "[cycle ...]"-s should be in an
#    ascending order. Constituent parameters are shifted so that they always start from 0. As an example:
#       "piecewise 0 const 10 , 1000 linear 10 0.01 , 2000 20"
#    There, in cycles 0-999 temperature is constant and equal 10, then in cycles 1000-1999 it grows linearly to 20
#    (to be precise, at cycle 1999 it is 19.99), and then it becomes 20 in 2000-th cycle and stays as such indefinitely.
#    Note, that for the 3-rd parameter a single value "20" was used equivalently to "const 20".
# It is important to note that last change of the temperature happens after the last thermalisation cycle and is frozen
# in the averaging stage. It is advisable to use a constant temperature for some number of cycles in the last part of
# the thermalization stage.
temperature = 1

# Pressure. It can be a floating-point constant or a dynamic parameter (see "temperature" for reference)
pressure = 0.1

# For how many full MC cycles the thermalization should be performed
thermalisationCycles = 10000

# For how many full MC cycles averaging should be performed
averagingCycles = 20000

# Ensemble averages are taken "[averagingEvery]" cycles
averagingEvery = 200

# How often instantaneous values of observables should be sampled
snapshotEvery = 100

# The name of the file to save internal representation of the packing. If empty, it is not generated. The internal
# representation
# encodes box size, particle positions and orientations, last Monte Carlo step amplitudes, the number of cycles and
# other package-specific information. The format may change at any moment
packingFilename = packing_gas.dat

# The name of the file to store the visualization of the final shapshot in the format of Wolfram
# Mathematica notebook. If empty, it is not generated.
wolframFilename = packing_gas.nb

# The name of output file to store ensemble-averaged observables in SSV format (space separated values). If empty, no
# file is generated. The first two columns are the temperature and pressure, while the next ones are mean values and
# standard errors of observables, whose computation is requested in  "observables" parameter. Names of columns are
# printed in the first row (the header). If the file already exists, the old one is not erased, but instead new rows are
# appended to the old one.
outputFilename = out.txt

# The name of file to output snapshot observable values every "snapshotEvery" cycles in SSV format (space separated
# values). Parameter names are printed in the first row (the header). First column is cycle number, next ones are values
# of observables.
observableSnapshotFilename = observable_gas.txt

# If not empty, trajectories of the particles will be stored in a compact binary RAMTRJ format. It then can be replayed
# for example to calculate different observables. Not all cycles are stored - it is done every "snapshotEvery" cycles.
recordingFilename = recording_gas.ramtrj

# The observables which should be computed during simulation. Each observables is in the format
# "([scope]) [observable name] ([observable-dependent parameters])"
#
# "[scope]" defines for which output type an observable should be computed. It can be one of:
# 1. "inline"
#    the observable is computed and printed on the standard output every 100 cycles. It may be useful for monitoring
#    the run in real time
# 2. "snapshot"
#    the observable is computed for every snapshot recorded in snapshot output file (see "observableSnapshotFilename"
#    parameter)
# 3. "averaging"
#    the observable is ensemble-averaged during averaging phase, printed on the standard output after the finished run
#    and to "outputFilename" output file (if specified)
# Scopes can be combined using "/" (without whitespace). For example "inline/snapshot numberDensity" will display number
# density on the standard output and include it in each row of the snapshot file, but ensemble value will not be
# computed. "[scope]" can be left empty - then is defaults to all three "inline/snapshot/averaging".
#
# Each observable consists of one or more interval and/or nominal values and they are printed separately in all of
# output scopes. Interval values are the ones that can be ensemble averaged, for example packing fraction, nematic order
# parameter etc. They are included in all requested scopes. Nominal values cannot be ensemble averaged, for example
# smectic parameter wavevector (it is a vector of integer values). They are included in inline and snapshot scope, but
# not in averaging.
#
# "[observable name]" is the name of the observable to be computed. Some observables have additional parameters
# "[observable-dependent parameters]" which follow right after the observable name. The full list of available
# observables is presented below. For each observable, its constituent values with their symbols are specified as
# sublist entries "x.y.". The type (interval/nominal) of values is also enlisted. Some observables have only one value,
# some have more.
# 1. "numberDensity"
#    number density of particles - the number of particles divided by the box volume. Constituent values:
#    1.1. "rho"
#         the number density; INTERVAL VALUE
# 2. "boxDimensions"
#    the dimensions of the simulation box. Constituent values:
#    2.1. "L_X"
#         x dimension of the box; INTERVAL VALUE
#    2.2. "L_Y"
#         y dimension of the box; INTERVAL VALUE
#    2.3. "L_Z"
#         z dimension of the box; INTERVAL VALUE
# 3. "packingFraction"
#    dimensionless packing fraction - the total volume occupied by particles divided by the box volume. Constituent
#    values:
#    3.1. "rho"
#         packing fraction; INTERVAL VALUE
# 4. "compressibilityFactor"
#    compressibility factor of the system, defined as (p*V)/(N*T). For ideal gas it is equal 1, for degenerate gases
#    it is bigger. Constituent values:
#    4.1. "Z"
#         compressibility factor; INTERVAL VALUE
# 5. "energyPerParticle"
#    interaction energy per particle (kinetic energy not included) - applies to soft potentials. Constituent values:
#    5.1. "E"
#         potential energy per particle; INTERVAL VALUE
# 6. "energyFluctuationsPerParticle"
#    variance of interaction energy per particle (kinetic energy not included) - applies to soft potentials. Constituent
#    values:
#    6.1. "varE"
#         variance of potential energy per particle; INTERVAL VALUE
# 7. "nematicOrder (dumpQTensor)"
#    P2 nematic order parameter computed as the highest magnitude eigenvalue of the nematic Q tensor. Main molecular
#    axes are shape-specific. Constituent values:
#    7.1. "P2"
#         nematic P2 parameter; INTERVAL VALUE
#    7.2. "Q_11"
#         (only if "dumpQTensor" specified) matrix element (1, 1) of Q-tensor; INTERVAL VALUE
#    7.3. "Q_12"
#         (only if "dumpQTensor" specified) matrix element (1, 2) of Q-tensor; INTERVAL VALUE
#    7.4. "Q_13"
#         (only if "dumpQTensor" specified) matrix element (1, 3) of Q-tensor; INTERVAL VALUE
#    7.5. "Q_22"
#         (only if "dumpQTensor" specified) matrix element (2, 2) of Q-tensor; INTERVAL VALUE
#    7.6. "Q_23"
#         (only if "dumpQTensor" specified) matrix element (2, 3) of Q-tensor; INTERVAL VALUE
#    7.7. "Q_33"
#         (only if "dumpQTensor" specified) matrix element (3, 3) of Q-tensor; INTERVAL VALUE
# 8. "smecticOrder ([n_x max] [n_y max] [n_z max]) (dumpTauVector)"
#    absolute value of smectic tau parameter (normalized by number density - 1 means maximal smectic order). The
#    tau value depends on the wavevector of smectic order parameter. Here, the one giving the highest value of taus
#    is selected from all PBC-compatible alternatives given by:
#    k = sum_alpha (n_alpha * g_alpha),
#    where g_alpha are reciprocal lattice vectors (which the box being the unit cell), while n_alpha are Miller indices
#    taken from [-"[n_alpha max]", "[n_alpha max]"] - the maximal length of the wavevector is controlled by an optional
#    parameter "[n_alpha max]". If it is not specified, it defaults to 5. Constituent values:
#    8.1. "tau"
#         absolute value of smectic order parameter; INTERVAL VALUE
#    8.2. "k_x"
#         (only if "dumpTauVector" specified) x coordinate of the wavevector of smectic order parameter; INTERVAL VALUE
#    8.3. "k_y"
#         (only if "dumpTauVector" specified) x coordinate of the wavevector of smectic order parameter; INTERVAL VALUE
#    8.4. "k_z"
#         (only if "dumpTauVector" specified) x coordinate of the wavevector of smectic order parameter; INTERVAL VALUE
#    8.5. "k_tau"
#         the wavevector of smectic order parameter in the format "[n_x].[n_y].[n_z]"; NOMINAL VALUE
# 9. "bondOrder [Miller indices] [rank 1] [rank 2] ..."
#    bond order parameter of a given rank "r" is computed by finding "r" nearest neighbours of a molecule, projecting
#    the vectors joining the molecule with neighbours onto the plane given by "[Miller indices]" with respect to the
#    simulation box, computing angles phi_j (j is the index of a neighbour) between the projections and an arbitrary
#    direction on this plane an then calculating
#    psi_r = 1/r sum_j exp(i r phi_j).
#    Nearest neighbours are also calculated using a projection onto a nearest smectic layer defined by
#    "[Miller indices]" (layer association is done using complex phase of the smectic parameter). Finally, the absolute
#    value of psi_r is averaged over all molecules in the system. "[Miller indices]" should be in format "[h].[k].[l]"
#    (negative values are allowed). At least one rank should be given. Constituent values:
#    9.x. "psi[rank]"
#         bond order parameter of rank "[rank]". There are as many of them as specified; INTERVAL VALUE
# 10. "rotationMatrixDrift"
#    squared Frobenius norm of the expression M M^T - 1, where M is an orientation of a given molecule. This observable
#    is useful to track the drift of orientation matrix errors cumulating during the simulation. Constituent values:
#    10.1. "F^2"
#          mean squared Frobenius norm, averages over all molecules in a snapshot; INTERVAL VALUE
#    10.2. "min(F^2)"
#          minimal squared Frobenius norm in a snapshot; INTERVAL VALUE
#    10.3. "max(F^2)"
#          maximal squared Frobenius norm in a snapshot; INTERVAL VALUE
# 11. "temperature"
#    current temperature of the system. Constituent values:
#    11.1. "T"
#          the temperature; INTERVAL VALUE
# 12. "pressure"
#    current pressure of the system. Constituent values:
#    12.1. "p"
#          the pressure; INTERVAL VALUE
observables = numberDensity , inline packingFraction , compressibilityFactor

# This is the end of parameters for "gas" run. Next ones are for subsequent "liquid" and "solid" runs. They have
# identical meaning, so the descriptions are not repeated.

[integration.liquid]
temperature = 1
pressure = 11.5
thermalisationCycles = 250000
averagingCycles = 200000
averagingEvery = 2000
snapshotEvery = 100
packingFilename = packing_liquid.dat
wolframFilename = packing_liquid.nb
outputFilename = out.txt
observableSnapshotFilename = observable_liquid.txt
recordingFilename = recording_liquid.ramtrj
observables = numberDensity , inline packingFraction , compressibilityFactor

[integration.solid]
temperature = 1
pressure = 20
thermalisationCycles = 1000000
averagingCycles = 2000000
averagingEvery = 20000
snapshotEvery = 100
packingFilename = packing_solid.dat
wolframFilename = packing_solid.nb
outputFilename = out.txt
observableSnapshotFilename = observable_solid.txt
recordingFilename = recording_solid.ramtrj
observables = numberDensity , inline packingFraction , compressibilityFactor
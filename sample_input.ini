# This is an example INI input file for the `casino' mode specifying the whole gas-liquid-solid simulation sequence for
# hard spheres. The user is encouraged to read the documentation carefully and run this test file to see how it works in
# practice.

########## HOW TO READ THE INSTRUCTION ##########

# Each parameter is described below. For a visual aid, all syntax element (parameters, their values and format) are
# written within double-quotes "...". Each parameter follows its own syntax - it could be for example three numbers
# separated by spaces, which will be denoted as "[number 1] [number 2] [number 3]". Each required parameter token is
# marked by square brackets "[...]" and explained, and the optional tokens are marked with round brackets "(...)".
# Tokens written without any brackets are literals. Each parameter may have multiple variants with a different syntax.
# They are presented using numbered lists "1.", "2.", ... . Some have sub-variants, which are enumerated using
# sub-lists, eg. "4.1.", "4.2.", ...


########## THE GENERAL SECTION ##########

# The file starts with the general section (which is anonymous INI section) specifying common parameters such as the
# molecule's shape, interaction type, etc. as well as the initial configuration, while subsequent sections named
# "\[run.[run_name]\]" (where \[ and \] are literal square brackets) describe runs (for example under different
# pressures or temperatures) that will be performed sequentially one by one. "[run_name]" is a user-defined name of the
# run (may be for example "gas", "liquid" and "crystal" as in this exemplary input file). The final snapshot of one run
# is the starting point for the next one. The initial configuration for the first run is configured using
# "initialDimensions", "initialArrangement" and "numOrParticles" parameters in this section.

# Below is the full list of general parameters with a detailed description of each.

# Initial dimensions of the orthorhombic simulation box. Supported variants:
# 1. "[x length] [y length] [z length]"
#    explicit box side lengths
# 2. "auto"
#    box size will be calculated automatically based on cell size from "initialArrangement"; this variant is supported
#    for variants 1.2, 1.4 and 2 of "initialArrangement"
initialDimensions = 100 100 100

# Initial arrangement of particles. Supported variants are 1. "orthorhombic" and 2. "presimulated" arrangement. The
# orthorhombic simulation box has cuboidal shape an a single particle in the unit cell. It has the following variants:
# 1.1. "orthorhombic ([clinicity]) ([polarization]) default"
#      cubic lattice of N x N x N particles with cell size calculated based on "initialDimensions" ("auto" value is
#      forbidden). N is calculated as a ceiling of cube root of "numOfParticles" parameter. "[polarization]" and
#      "[clinicity]" are optional parameters allowing to create antipolar and/or tilted layouts. They are described
#      below
# 1.2. "orthorhombic ([clinicity]) ([polarization]) spacing [spacing value] [axis order] [num molecules x] [... y] \
#       [... z]"
#      this variant automatically optimizes cell size for "[num molecules x]" times "[... y]" times "[... z]" lattice,
#      so that the distance between the molecules is "[spacing value]". The box size is always fitted automatically -
#      the value from "initialDimensions" is ignored. The procedure is performed as follows: first the algorithm
#      calculates the minimal lattice cell dimensions (so that all particles are tangent). The optimization is performed
#      axis-by-axis in the order given by "[axis order]", for example "xzy". In the exemplary "xzy" case, the optimizer
#      will create a dilute lattice (with the target polarization, clinicity and number of particles), then it will
#      maximally shrink the packing: first in x direction, after that in z direction and finally in y direction.
#      Orientations of particle are not changed, only the mass centres. Finally, the obtained cell sizes will be
#      increased by "[spacing value]". The final result may vary depending on "[axis order]", however the configuration
#      is guaranteed not to overlap. The order giving the optimal spacing should be carefully chosen basing on the
#      molecule's shape. The "preview" program mode may come in handy (see README.md or ./rampack --help)
# 1.3. "orthorhombic ([clinicity]) ([polarization]) [num molecules x] [... y] [... z]
#      this variant calculates lattice cell dimensions based on "initialDimensions" parameter and number or molecules in
#      each direction of the lattice: [num molecules x], [... y] and [... z]
# 1.4. "orthorhombic ([clinicity]) ([polarization]) [num molecules x] [... y] [... z] [cell size x] [... y] [... z]
#      in this variant cell length and number of molecules in each direction is specified explicitly. If the box size
#      is specified explicitly in "initialDimensions" and is bigger than the whole lattice, the lattice will be placed
#      in the middle of the simulation box. For "initialDimensions = auto", the box size will be fitted to the lattice
#
# In all cases "numberOfParticles" parameter is respected - when the product of number of particles in each direction of
# the lattice is bigger, some slots will not be filled. For example 10 x 10 x 10 lattice for 500 particles will be
# filled exactly in half (leaving the other half of the simulation box empty).
#
# "[clinicity]"
# controls the tilt within the layer of particles occurring for example in smectic and crystal phases. The wavevector of
# layers (the direction orthogonal to layer planes) is given by "[polarization axis]" in "[polarization]"
# - "[polarization]" has to be always specified together with "[clinicity]". "[clinicity]" has the format:
#
# "{synclinic|anticlinic} [tilt axis] [tilt angle]"
#
# "synclinic" means that in each layer particles are tilted in the same direction, "anticlinic" - in one direction for
# even layers and in the other direction for odd layers. The tilt is applied by rotating each molecule around
# "[tilt axis]" ("x", "y" or "z") by +/- "[tilt angle]" degrees. If "[clinicity]" is not specified, it defaults
# to no tilt at all.
#
# "[polarization]"
# controls the polarization within layers and specifies the actual direction of them (direction orthogonal to layer's
# plane). It has the format:
#
# "{polar|antipolar} [polarization axis]"
#
# "polar" means that all secondary axes (polarization axes) of particles are oriented in the same direction (the default
# orientation of the particle), while for "antipolar" interchangeably - particles in even layers are not rotated, while
# in odd layers they are rotated by 180 degrees around the "[polarization axis]". "[polarization axis]" thus defines the
# wavevector of layering. "(polarization)" can be specified without "(clinicity)", however the former is required for
# the latter and then "[polarization axis]" also controls clinicity
#
# "presimulated" arrangement has a single variant:
# 2. "presimulated [dat packing file name]"
#    it loads the initial configuration from internal dat packing representation, which can be for example the final
#    snapshot of other simulation or be generated using ./rampack preview mode
initialArrangement = lattice default

# The number of molecules to be simulated
numOfParticles = 1000

# The initial step size for translational moves - each component of translation vector will be sampled uniformly from
# [-"positionStepSize", "positionStepSize"] interval. The step size will be adjusted dynamically during thermalization
# phase so that acceptance ratio is around 0.15.
positionStepSize = 10

# The initial step size for rotational moves - rotation is performed around a random axis by an angle uniformly sampled
# from [-"rotationStepSize", "rotationStepSize"] interval. Rotation step size is adjusted dynamically in a similar
# fashion to the translational one. Those two are always adjusted simultaneously by the same factor, so they ratio stays
# constant. The ratio can be selected heuristically by benchmarking, or using a rule of thumb: maximal rotation should
# move the furthest part of the particle by the same amount as the maximal translation.
rotationStepSize = 0.1

# The maximal size of the volume move and the type of the scaling. Notice that some types allow independent moves for
# some or all sides which allows to relax the diagonal part of stress tensor (directional pressures). Alternatives for
# "scalingType":
# 1. "delta V"
#    The ratio of all box sides remains constant while the volume is changed by an amount sampled from
#    [-"volumeStepSize", "volumeStepSize"] interval
# 2. "linear [variant-dependent parameters]"
#    instead of the volume, it perturbs the box side lengths by a value from a uniformly sampled interval
#    [-"volumeStepSize", "volumeStepSize"]. The perturbation for each side may be independent or not, depending on the
#    variant:
#    2.1. "linear isotropic"
#         All dimensions are changed using the same random number. Note, however, that the ratio of side lengths remains
#         constant only for a cubic box.
#    2.2. "linear anisotropic [axes]"
#         If "[axes]" is on of: "x", "y" or "z", the side length corresponding to this axis will be perturbed using a
#         different (independent) random number for than the two other axes. If "[axes]" is "xyz", all three sides will
#         be perturbed independently.
# 3. "(independent) log [variant-dependent parameters]"
#    All side lengths are scaled by multiplication by a factor instead of addition. The factor is sampled \
#    logarithmically - first a number x_alpha is sampled uniformly from [-"volumeStepSize", "volumeStepSize"] interval.
#    Then, the scaling factor is calculated as exp(x_alpha). Scaling factor for each side may be independent of not
#    depending on the variant.
#    3.1. "log isotropic"
#         All sides are scaled by the same factor.
#    3.2. "log anisotropic [axis]"
#         If "[axis]" is "x", "y" or "z", this axis is scaled by a different factor than two other. If "[axis]" is
#         "xyz", all three axes are scaled by three independent factors. In either case all axes are scaled
#         simultaneously.
#    3.2. "independent log anisotropic [axis]"
#         Similar as 3.2, but independent scaling directions (as specified by "[axis]") are scaled one at a time. For
#         example "independent log anisotropic x" means that either: x axis is scaled and y, z are unaltered, or y and z
#         are scaled and x is unaltered - both options with the same probability. "independent log anisotropic xyz"
#         means scaling one side at a time.
# 4. "(independent) delta triclinic"
#    Box side vectors are translated by random vectors with coordinates sampled uniformly from
#    [-"volumeStepSize", "volumeStepSize"] interval. This scaling types enables to perform simulations in
#    isobaric-isotension ensemble (relaxing off-diagonal parts of stress tensor). If "independent" is specified, only a
#    single, randomly sample side will be perturbed. Otherwise, all are perturbed at once.
scalingType = delta V
volumeStepSize = 1000

# The seed for random number generator
seed = 1234

# The shape of the molecule. It is specified by "shapeName", while its (shape-dependent) parameters, such as eg. the
# axis ratio are given by "shapeAttributes". Each shape may support one ore more interaction types. A full list of
# shapes, together with their attributes and interactions is given below. "shapeName" is presented together with
# "shapeAttributes" in the format "[shape name] (shape attributes)". For each list entry (a single shape) all supported
# interaction are shown as a sublist.
# 1. "Sphere [radius]"
#    sphere with a radius "[radius]". Supported interaction types:
#    1.1. "hard"
#         hard-core interaction
#    1.2. "lj [epsilon] [sigma]"
#         Lennard-Jones interaction with a standard definition of "[epsilon]" and "[sigma]" parameters:
#         LJ(r) (4 epsilon ((sigma/r)^12 - (sigma/r)^6)
#         r is the distance between interaction centers
#    1.3. "repulsive_lj [epsilon] [sigma]"
#         Lennard-Jones, but only the repulsive part - the so-called Weeks-Chandler-Anderson potential:
#         LJ(r) + epsilon   for r < 2^(1/6),
#         0                 for r >= 2^(1/6).
# 2. "Spherocylinder [length] [radius]"
#    spherocylinder with cap radius "[radius]" (or, equivalently, half-width) and the distance between cap centers
#    "[length]". For the default orientation, "Spherocylinder" is aligned with x axis. Supported interactions:
#    2.1. "hard"
#         hard-core interaction
# 3. "KMer [number of spheres] [radius] [distance]"
#    a linear chain of "[number of spheres]" spheres with radius "[radius]". The centers are equally spaced with a
#    distance "[distance]". Supported interactions:
#    3.1. "hard"
#         same as for "Sphere", however each pair of beads is treated separately
#    3.2. "lj [epsilon] [sigma]"
#         same as for "Sphere", however each pair of beads is treated separately
#    3.3. "repulsive_lj [epsilon] [sigma]"
#         same as for "Sphere", however each pair of beads is treated separately
# 4. "PolysphereBanana [arc radius] [arc angle] [number of spheres] [sphere radius]"
#    chain of "[number of spheres]" spheres with radius "[sphere radius]" placed on an arc (banana-shaped). The arc is
#    defined by its radius "[arc radius]" and arc angle "[arc angle]". The centres of spheres are equidistantly placed
#    on the arc and its endpoints are at the same time the centres of outermost spheres. The centers of spheres in
#    "PolysphereBanana" molecule with a default orientation lie within xy plane, the main axis (joining the ends of the
#    arc) is y axis and the arc is bent towards the negative x semi-axis (the vector joining either endpoint and the
#    middle has a negative x component). Supported interactions:
#    4.1. "hard"
#         same as for "Sphere", however each pair of beads is treated separately
#    4.2. "lj [epsilon] [sigma]"
#         same as for "Sphere", however each pair of beads is treated separately
#    4.3. "repulsive_lj [epsilon] [sigma]"
#         same as for "Sphere", however each pair of beads is treated separately
# 5. "PolyspherocylinderBanana [arc radius] [arc angle] [number of segments] [radius] ([subdivisions])"
#    a molecule similarly shaped as "PolysphereBanana", but using spherocylinders. "[arc radius]" and "[arc angle]" have
#    identical meaning as in "PolysphereBanana", "[radius]" is the radius of spherocylinders' caps (equivalently their
#    half-width). "[number of segments]" is a number of spherocylinders used to approximate the arc - the arc is divided
#    into that many segments and spherocylinders are placed around them. The default orientation is analogous to
#    "PolysphereBanana". If the optional parameter "[subdivisions]" is specified, each spherocylinder is divided into
#    that many parts - it does not change the physics, but may increase the speed of the simulation. Default value is 1
#    (no divisions). Supported interactions:
#    5.1. "hard"
#         hard-core repulsion of each pair of spherocylinders
shapeName = Sphere
shapeAttributes = 0.5
interaction = hard

# Number of parallel threads used to perform volume moves
scalingThreads = 4

# The parallelization of molecule moves is done using the domain division - the space is divided into cuboidal subspaces
# with inactive (ghost) layers between them. This parameter specifies how many divisions should be made in each
# direction. Each domain is then assigned to a separate thread. As a result, the number of threads is the product of the
# number of divisions in each direction. Format:
# "[number of divisions in x direction] [... y ...] [... z ...]"
# Optimally one should use the same number of threads for both volume and molecule moves. A lower number of scaling
# threads than molecule threads is forbidden. Then "1 1 1" is given, domain division will be deactivated.
domainDivisions = 2 2 1

# If true, the current run will be stored, when SIGINT or SIGTERM is received. It means that all specified output files
# will be produced. The run can be continued later using the standard --continue option. If false, the run will be
# permanently lost.
saveOnSignal = true


########## RUNS AND RUN SPECIFIC PARAMETERS ##########

# In this exemplary input file there are three runs with names: "gas", "liquid" and "solid". Each run has a set of its
# own parameters such as temperature, pressure, observables to be calculated, etc. The run starts with thermalization
# phase in which the system should reach its equilibrium state. After that, the averaging phase follows, when ensemble
# averages of the observables are computed. During averaging phase the auto-adjustment of molecule an volume move
# amplitudes is turned off. After the finished run ensemble averages of observables are printed on the standard output.
# Moreover one can request to output the following auxiliary data:
# 1. internal representation of the packing
# 2. Wolfram Mathematica notebook with the visualisation of the final snapshot
# 3. output file with ensemble averages (the same ones as are printed on the standard output by default)
# 4. instantaneous values of the observables every N cycles
# The observables to compute are specified using "observables" parameter.

# Each run is an INI section with the format "\[run.[run name]\]" - "[run name]" is user-specified unique name of the
# run
[run.gas]

# Temperature in k_B units
temperature = 1

# Pressure
pressure = 0.1

# For how many full MC cycles the thermalization should be performed
thermalisationCycles = 10000

# For how many full MC cycles averaging should be performed
averagingCycles = 20000

# Ensemble averages are taken "[averagingEvery]" cycles
averagingEvery = 200

# How often instantaneous values of observables should be sampled
snapshotEvery = 100

# The name of the file to save internal representation of the packing. If empty, it is not generated. The internal
# representation
# encodes box size, particle positions and orientations, last Monte Carlo step amplitudes, the number of cycles and
# other package-specific information. The format may change at any moment
packingFilename = packing_gas.dat

# The name of the file to store the visualization of the final shapshot in the format of Wolfram
# Mathematica notebook. If empty, it is not generated.
wolframFilename = packing_gas.nb

# The name of output file to store ensemble-averaged observables in SSV format (space separated values). If empty, no
# file is generated. The first two columns are the temperature and pressure, while the next ones are mean values and
# standard errors of observables, whose computation is requested in  "observables" parameter. Names of columns are
# printed in the first row (the header). If the file already exists, the old one is not erased, but instead new rows are
# appended to the old one.
outputFilename = out.txt

# The name of file to output snapshot observable values every "snapshotEvery" cycles in SSV format (space separated
# values). Parameter names are printed in the first row (the header). First column is cycle number, next ones are values
# of observables.
observableSnapshotFilename = observable_gas.txt

# The observables which should be computed during simulation. Each observables is in the format
# "([scope]) [observable name] ([observable-dependent parameters])"
#
# "[scope]" defines for which output type an observable should be computed. It can be one of:
# 1. "inline"
#    the observable is computed and printed on the standard output every 100 cycles. It may be useful for monitoring
#    the run in real time
# 2. "snapshot"
#    the observable is computed for every snapshot recorded in snapshot output file (see "observableSnapshotFilename"
#    parameter)
# 3. "averaging"
#    the observable is ensemble-averaged during averaging phase, printed on the standard output after the finished run
#    and to "outputFilename" output file (if specified)
# Scopes can be combined using "/" (without whitespace). For example "inline/snapshot numberDensity" will display number
# density on the standard output and include it in each row of the snapshot file, but ensemble value will not be
# computed. "[scope]" can be left empty - then is defaults to all three "inline/snapshot/averaging".
#
# Each observable consists of one or more interval and/or nominal values and they are printed separately in all of
# output scopes. Interval values are the ones that can be ensemble averaged, for example packing fraction, nematic order
# parameter etc. They are included in all requested scopes. Nominal values cannot be ensemble averaged, for example
# smectic parameter wavevector (it is a vector of integer values). They are included in inline and snapshot scope, but
# not in averaging.
#
# "[observable name]" is the name of the observable to be computed. Some observables have additional parameters
# "[observable-dependent parameters]" which follow right after the observable name. The full list of available
# observables is presented below. For each observable, its constituent values with their symbols are specified as
# sublist entries "x.y.". The type (interval/nominal) of values is also enlisted. Some observables have only one value,
# some have more.
# 1. "numberDensity"
#    number density of particles - the number of particles divided by the box volume. Constituent values:
#    1.1. "rho"
#         the number density; INTERVAL VALUE
# 2. "boxDimensions"
#    the dimensions of the simulation box. Constituent values:
#    2.1. "L_X"
#         x dimension of the box; INTERVAL VALUE
#    2.2. "L_Y"
#         y dimension of the box; INTERVAL VALUE
#    2.3. "L_Z"
#         z dimension of the box; INTERVAL VALUE
# 3. "packingFraction"
#    dimensionless packing fraction - the total volume occupied by particles divided by the box volume. Constituent
#    values:
#    3.1. "rho"
#         packing fraction; INTERVAL VALUE
# 4. "compressibilityFactor"
#    compressibility factor of the system, defined as (p*V)/(N*T). For ideal gas it is equal 1, for degenerate gases
#    it is bigger. Constituent values:
#    4.1. "Z"
#         compressibility factor; INTERVAL VALUE
# 5. "energyPerParticle"
#    interaction energy per particle (kinetic energy not included) - applies to soft potentials. Constituent values:
#    5.1. "E"
#         potential energy per particle; INTERVAL VALUE
# 6. "energyFluctuationsPerParticle"
#    variance of interaction energy per particle (kinetic energy not included) - applies to soft potentials. Constituent
#    values:
#    6.1. "varE"
#         variance of potential energy per particle; INTERVAL VALUE
# 7. "nematicOrder"
#    P2 nematic order parameter computed as the highest magnitude eigenvalue of the nematic Q tensor. Main molecular
#    axes are shape-specific. Constituent values:
#    7.1. "P2"
#         nematic P2 parameter; INTERVAL VALUE
# 8. "smecticOrder ([n_x max] [n_y max] [n_z max])"
#    absolute value of smectic tau parameter (normalized by number density - 1 means maximal smectic order). The
#    tau value depends on the wavevector of smectic order parameter. Here, the one giving the highest value of taus
#    is selected from all PBC-compatible alternatives given by:
#    k = (k_x, k_y, k_z),
#    k_alpha = 2 pi n_alpha / L_alpha (alpha = x, y, z),
#    where L_alpha is the length of box side alpha, while n_alpha is an integer from the interval
#    [-"[n_alpha max]", "[n_alpha max]"] - the maximal length of the wavevector is controlled by an optional parameter
#   "[n_alpha max]". If it is not specified, it defaults to 5. Constituent values:
#    8.1. "tau"
#         absolute value of smectic order parameter; INTERVAL VALUE
#    8.2. "k_tau"
#         the wavevector of smetcic order parameter in the format "[n_x].[n_y].[n_z]"; NOMINAL VALUE
observables = numberDensity , inline packingFraction , compressibilityFactor

# This is the end of parameters for "gas" run. Next ones are for subsequent "liquid" and "solid" runs. They have
# identical meaning, so the descriptions are not repeated.

[run.liquid]
temperature = 1
pressure = 11.5
thermalisationCycles = 250000
averagingCycles = 200000
averagingEvery = 2000
snapshotEvery = 100
packingFilename = packing_liquid.dat
wolframFilename = packing_liquid.nb
outputFilename = out.txt
observableSnapshotFilename = observable_liquid.txt
observables = numberDensity , inline packingFraction , compressibilityFactor

[run.solid]
temperature = 1
pressure = 20
thermalisationCycles = 1000000
averagingCycles = 2000000
averagingEvery = 20000
snapshotEvery = 100
packingFilename = packing_solid.dat
wolframFilename = packing_solid.nb
outputFilename = out.txt
observableSnapshotFilename = observable_solid.txt
observables = numberDensity , inline packingFraction , compressibilityFactor
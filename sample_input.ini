# This is an example INI input file for the `casino' mode specifying the whole gas-liquid-solid simulation sequence for
# hard spheres.

# Each parameter is described below. For a visual aid, all syntax element (parameters, their values and format) are
# written within double-quotes "...". Each parameter follows its own syntax, for example three numbers separated by
# spaces. Each required parameter token is marked by square brackets "[...]" and explained, and the optional tokens
# are marked with round brackets "(...)". Tokens written without any brackets are literals. Each parameter may have
# multiple variants with a different syntax. They are marked by numbers "x.". Some have subvariants, which are marked
# with two numbers "x.y.".

# The file starts with the general section specifying common parameters such as the shape, interaction,
# etc. and the initial configuration, while subsequent sections named "\[run.[run_name]\]" (where \[ and \] are literal
# square brackets) describe sequentially performed runs (for example under different pressures or temperatures).
# "[run_name]" is a user-defined name of the run (may be for example "gas", "liquid" and "crystal" as in this exemplaty
# input file). The final snapshot of one run is a starting point for the next one. The initial configuration for the
# first run is described in the general section.

# Initial dimensions of the orthorombic simulation box. Supported variants:
# 1. "[x length] [y length] [z length]"
#    explicit box side lengths
# 2. "auto"
#    box size will be calculated automatically based on cell size from "initialArrangement"; this variant is supported
#    for variants 1.2, 1.4 and 2 of "initialArrangement"
initialDimensions = 100 100 100

# Initial arrangement of particles. Supported variants are 1. "orthorombic" and 2. "presimulated" arrangement. The
# subvariants for the former one:
# 1.1. "orthorombic ([clinicity]) ([polarization]) default"
#      cubic lattice of N x N x N particles with cell size calculated based on "initialDimensions" ("auto" value is
#      forbidden). "N" is calculated as a ceiling of cube root of "numOfParticles" parameter. "(polarization)" and
#      "(clinicity)" are optional parameters allowing to create antipolar and/or tilted layouts. They are described
#      below
# 1.2. "orthorombic (clinicity) (polarization) spacing [spacing value] [axis order] [num particles x] [... y] [... z]"
#      this variant automatically optimizes cell size for "[num particles x]" times "[... y]" times "[... z]" lattice, so that
#      the distance between the molecules is "[spacing value]" distance. The box size is always fitted automatically -
#      the value from "initialDimensions" is ignored. The procedure is performed as follows: first the algorithm
#      calculates the minimal cell dimensions (so that all particles are tangent). The optimization is performed
#      axis-by-axis in the order given by "[axis order]", for example "xzy". In such a case the optimizer will create
#      dilute lattice (with the specified polarization, clinicity and number of particles), then it will maximally
#      shrink is in x direction, then in z direction and finally in y direction. Finally, the obtained cell sizes are
#      increased by "[spacing value]". The final result may vary depending on the order of axes, however it is guaranteed
#      not to overlap. The order giving optimal spacing should be picked out basing on the molecule's shape
# 1.3. "orthorombic (clinicity) (polarization) [num particles x] [... y] [... z]
#      this variant calculates cell lengths based on "initialDimensions" parameter and number or particles in each
#      direction: [num particles x], [... y] and [... z]
# 1.4. "orthorombic (clinicity) (polarization) [num particles x] [... y] [... z] [cell size x] [... y] [... z]
#      in this variant cell length and number of particle in each dimensions is specified explicitly. If the box size
#      is specified explicitly in "initialDimensions" and is bigger than the whole lattice, the lattice will be placed
#      in the middle. For "initialDimenaions = auto", the box size will be calculated based on the lattice size
#
# In all cases "numberOfParticles" parameter is respected - when the product of number of particles in each direction of
# the lattice is bigger, some slots will not be filled. For example 10 x 10 x 10 lattice for 500 particles will be
# filled exactly in half.
#
# "(clinicity)"
# controls the tilt within the layer of particles occurring for example in smectic and crystal phases. The
# wavevector of layers (the direction orthogonal to layer planes) is given by "[polarization axis]" in "(polarization)"
# - "(polarization)" has to be specified together with "(clinicity)". "(clinicity)" has the format:
#
# "{synclinic|anticlinic} [tilt axis] [tilt angle]"
#
# "synclinic" means that in each layer particles are tilted in the same direction, "anticlinic" - in one direction
# for even layers and in the second one for odd layers. The tilt is applied by rotating each molecule in layer-specific
# direction around [tilt axis] ("x", "y" or "z") by [tilt angle] degrees. If (clinicity) is not specified, it defaults
# to no tilt at all.
#
# "(polarization)"
# controls the polarization within layers and specifies the actual direction of them (direction
# orthogonal to layer's plane). It has the format:
#
# "{polar|antipolar} [polarization axis]"
#
# "polar" means that all secondary axes (polarization axes) of particles are oriented in the same direction, default
# for the particle, while for "antipolar" interchangibly - particles in even layers are not rotated, while in odd layers
# they are rotated by 180 degrees around the "[polarization axis]". "[polarization axis]" thus defines the wavevector
# of layering. "(polarization)" can be specified without "(clinicity)", however the former is required for the latter
#
# "presimulated" arrangement has a single variant:
# 2. "presimulated [dat packing file name]"
#    it load the initial configuration from internal dat packing representation, which can be for example final snapshot
#    of other simulation.
initialArrangement = lattice default

# The number of simulated molecules
numOfParticles = 1000

# The initial step size for translational moves - each component of translation vector will be sampled uniformly from
# [-"positionStepSize", "positionStepSize"] interval. The step size will be adjusted dynamically during thermalization
# phase so that acceptance ratio is around 0.15.
positionStepSize = 10

# The initial step size for rotational moves - rotation is performed around a random axis by angle uniformly sampled
# from [-"rotationStepSize", "rotationStepSize"] interval. Rotation step size is adjusted dynamically in a similar
# fashion to the translational one. They are always adjusted simultaneously by the same factor, so they ratio stays
# constant. The ratio can be selected heuristically by benchmarking, or using a rule of thumb: maximal rotation should
# move the furthest part of the particle by the same amount as the maximal translation.
rotationStepSize = 0.1

# The maximal size of the volume move and the type of the scaling. Alternatives for "scalingType":
# 1. "delta V"
#    The ratio of all box sides remains constant while the volume is changed by an amount sampled from
#    [-"volumeStepSize", "volumeStepSize"] interval
# 2. "linear [variant-dependent parameters]"
#    instead of the volume, the box sides are perturbed by a value from a
#    uniformly sampled interval. "volumeStepSize" is the geometric average of amplitude of side length perturbation
#    - the amplitude for each dimension is scaled proportionally to side length, so for alpha=x, y, z side the
#    the perturbation is selected from [-Dalpha, Dalpha] interval, where
#    Dalpha = "volumeStepSize" * (alpha box length) / (box volume)^(1/3)
#    A small correction is done for the expansion moves to preserve Markov-chain detailed balance. The perturbation for each
#    side may be independent or not, depending on the variant
#    2.1. "linear isotropic"
#         All dimensions are scaled using the same random number, meaning that the box side length ratio remains
#         constant
#    2.2. "linear anisotropic [axes]"
#         If "[axes]" is "x", "y" or "z", the side length corresponding to this axis will be perturbed using a different
#         (independent) random number than two other axes, which will be using by the same number. If "[axes]" is
#         "xyz", all three sides will be perturbed independently. In both cases two or all side length ratios of the
#         simulation box change which allows to relax the diagonal part of stress tensor (directional pressures).
#         Note that regardless of which sides are perturbed independently, the actual length changes are always
#         computed according to the above equation for Dalpha
# 3. "logarithmic [variant-dependent parameters]"
#    All side length are scaled by multiplication by a factor instead of addition. The factor is samples logarithmically
#    - first a number Dalpha is sampled uniformly from [-"volumeStepSize", "volumeStepSize"] interval. Then, the scaling
#    factor is calculated as exp(Dalpha). Scaling factor for each side may be independent of not for different variants.
#    3.1. "log isotropic"
#         All sides are scaled by the same factor.
#    3.2. "log anisotropic [axis]"
#         If "[axis]" is "x", "y" or "z", this axis is scaled by a different factor than two other. If "[axis]" is
#         "xyz", all three axes are scaled by three independent factors. In either case all axes are scaled.
#    3.2. "independent log anisotropic [axis]"
#         Similar as 3.2, but independent scaling directions (as specified by "[axis]") are scaled one at a time.
#         For example "independent log anisotropic x" means that either: x axis is scaled and y, z are unaltered, or y and z are
#         scaled and x is unaltered - both options with the same probability. "independent log anisotropic xyz" means
#         scaling one side at a time.
scalingType = delta V
volumeStepSize = 1000

# The seed for random number generator
seed = 1234

# The shape of the molecule. It is specified by "shapeName", while its (shape-dependent) parameters, such as axis ratio is given by
# "shapeAttributes". Each shape may support one ore more interaction. A full list of shapes, together with their
# attributes and interactions is given below. It is in a format "[shape name] (shape attributes)", after which follows
# the list of supported interactions.
# 1. "Sphere [radius]" - sphere of radius "[radius]"
#    1.1. "hard" - hard-core interaction
#    1.2. "lj [epsilon] [sigma]" - Lennard-Jones interaction with a standard definition of "[epsilon]" and "[sigma]"
#         parameters (4 epsilon ((sigma/r)^12 - (sigma/r)^6))
#    1.3. "repulsive_lj [epsilon] [sigma]" - Lennard-Jones, but only the repulsive part (Weeks-Chandler-Anderson
#         potential (LJ(r) + epsilon for r < 2^(1/6), 0 otherwise)
# 2. "Spherocylinder [length] [radius]" - spherocylinder with cap radius "[radius]" and the distance between cap centres
#    "[length]". For the default orientation, "Spherocylinder" is aligned with x axis.
#    2.1. "hard" - hard-core interaction
# 3. "KMer [number of spheres] [radius] [distance]" - a linear chain of "[number of spheres]" spheres with radius
#    "[radius]". The centers are equally spaced with a distance "[distance]".
#    3.1. "hard" - same as for "Sphere"
#    3.2. "lj [epsilon] [sigma]" - same as for "Sphere"
#    3.3. "repulsive_lj [epsilon] [sigma]" - same as for "Sphere"
# 4. "PolysphereBanana [arc radius] [arc angle] [number of spheres] [sphere radius]" - chain of "[number of spheres]"
#    spheres with radius "[sphere radius]" placed on an arc (banana-shaped). The arc is defined by its radius
#    "[arc radius]" and arc angle "[arc angle]". The centres of spheres are equidistantly placed on the arc and the
#    endpoints of the arc are the centres of outermost spheres. "PolysphereBanana" with a default orientation lies
#    within xy plane, the main axis (joining the ends of the arc) is y axis and the arc is bent towards the negative
#    x semiaxis (the open part of the arc is directed towards positive x semiaxis)
#    4.1. "hard" - same as for "Sphere"
#    4.2. "lj [epsilon] [sigma]" - same as for "Sphere"
#    4.3. "repulsive_lj [epsilon] [sigma]" - same as for "Sphere"
# 5. "PolyspherocylinderBanana [arc radius] [arc angle] [number of segments] [radius] (subdivisions = 1)" - a molecule
#    similarly shaped as "PolysphereBanana", but using spherocylinders. "[arc radius]" and "[arc angle]" have identical
#    meaning as in "PolysphereBanana", "[radius]" is the radius of spherocylinders' caps (equivalently their
#    half-width). "[number of segments]" is a number of spherocylinders used to approximate the arc - the arc is divided
#    into this many segments and spherocylinders are built on top of them. The default orientation is analogous to
#    "PolysphereBanana".
#    5.1. "hard" - hard-core repulsion
shapeName = Sphere
shapeAttributes = 0.5
interaction = hard

# Number of parallel threads used for volume moves
scalingThreads = 4

# The paralellization of molecule moves is done using a domain division - the space is divided into cuboidal subspaces
# with inactive layers between them. This parameter specifies how many divisions should be made in each direction.
# The number of threads is the product of the number of divisions. Format:
# "[number of divisions in x direction] [... y ...] [... z ...]"
# Optimally one should use the same number of threads for both volume and particle moves. A lower number of scaling
# threads than molecule threads is forbidden
domainDivisions = 2 2 1

# There are three runs here with names: "gas", "liquid" and "solid". Each run has parameters specific for it. Each run
# can have a specific temperature, pressure, observables, etd. The run starts with thermalization phase in which the
# system should reach its equilibrium state. After that, the averaging phase follows, when ensemble averages of
# the observables are computed. During averaging phase the adjusting of Monte Carlo molecule an volume move amplitudes
# is turned off. After the finished run ensemble averages of observables are printed on the standard output. Moreover
# one can request to store one or more of:
# 1. internal representation of the packing for later use
# 2. Wolfram Mathematica notebook with the visualisation of the final shapshot
# 3. output file with ensemble averages (the same as in the standard output)
# 4. snapshots of the observables during the whole run
# The observables are specified by "observables" parameter

# Each run is an INI section in the format "\[run.[run name]\]"
[run.gas]

# Temperature in k_B units
temperature = 1

# Pressure
pressure = 0.1

# How many cycles the thermalization should be performed
thermalisationCycles = 10000

# How many cycles for averaging should be performed
averagingCycles = 20000

# Ensemble averages are taken only every n cycles. This controls this number
averagingEvery = 200

# How often
snapshotEvery = 100

# The name of the file to save internal representation of the packing. If empty, it is not generated. The internal
# representation
# encodes box size, particle positions and orientations, last Monte Carlo step amplitudes, the number of cycles and
# other package-specific information. The format may change at any moment
packingFilename = packing_gas.dat

# The name of the file to store the visualization of the final shapshot in the format of Wolfram
# Mathematica notebook. If empty, it is not generated.
wolframFilename = packing_gas.nb

# The name of output file to store ensemble-averaged observables in SSV format (space separated values). If empty, no file is generated. The first two columns
# are the temperature and pressure, while the next ones are mean values and standard errors of observables, which are
# specified in "observables" parameter. Names of columns are printed in the first row (as a header). If the file already
# exists, new rows are appended to the old one.
outputFilename = out.txt

# The name of file to output snapshot observable values every "snapshotEvery" cycles in SSV format (space separated
# values). The file contains the header with parameter names. First column is cycle number, next ones are values
# of observables.
densitySnapshotFilename = density_gas.txt

# The observables which should be computed during simulation. Each observables is in the format
# ([scope]) [observable name] ([observable-dependent parameters])
#
# "[scope]" defines for which output type an observable should be computed. It can be one of:
# 1. "inline"
#    the observable is computed and printed on the standard output every 100 cycles. It may be useful for monitoring
#    the run in real time
# 2. "snapshot"
#    the observable is computed and printed in snapshot output file (see "densitySnapshotFilename" parameter)
# 3. "averaging"
#    the observable is ensemble-averaged during averaging phase, printed on the standard output after the finished run
#    and to "outputFilename" output file if specified
# Scopes can be combined using "/" (WITHOUT SPACES). For example "inline/shapshot numberDensity" will display number
# density inline and include it in each row of the snapshot file, but ensemble value will not be computed. Scope can
# be left empty - then is defaults to all three "inline/snapshot/averaging".
#
# Each observable consists one or more interval and/or nominal values and they are printed separately in all of output
# scopes. Interval values are the ones that can be
# ensemble averaged, for example packing fraction, nematic order parameter etc. They are included in all scopes. Nominal
# values cannot be ensemble averaged, for example smectic parameter wavevector (it is a vector of integer values). They
# are included in inline and snapshot scope, but not in averaging.
#
# "[observable name]" is the name of the observable to be computed. Some observables have additional parameters
# "[observable-dependent parameters]" which follow right after the observable name. The full list of available
# observables is presented below. The description of each observable lists all constituent values, together with their
# symbols and type within separate sublist entries "x.y.". Some observables have only one value, some have more.
# 1. "numberDensity"
#    number density of particles - the number of particles divided by box volume. Constituent values:
#    1.1. "rho"
#         the number density; INTERVAL VALUE
# 2. "boxDimensions"
#    the dimensions of the simulation box. Constituent values:
#    2.1. "L_X"
#         x dimension of the box; INTERVAL VALUE
#    2.2. "L_Y"
#         y dimension of the box; INTERVAL VALUE
#    2.3. "L_Z"
#         z dimension of the box; INTERVAL VALUE
# 3. "packingFraction"
#    dimensionless packing fraction - the total volume occupied by particles divided by the box volume. Constituent
#    values:
#    3.1. "rho"
#         packing fraction; INTERVAL VALUE
# 4. "compressibilityFactor"
#    compressibility factor of the system, defined as (p*V)/(N*T). For ideal gas it is equal 1, for degenerate gases
#    it is bigger. Constituent values:
#    4.1. "Z"
#         compressibility factor; INTERVAL VALUE
# 5. "energyPerParticle"
#    interaction energy per particle (kinetic energy not included) - applies to soft potentials. Constituent values:
#    5.1. "E"
#         potential energy per particle; INTERVAL VALUE
# 6. "energyFluctuationsPerParticle"
#    variance of interaction energy per particle (kinetic energy not included) - applies to soft potentials. Constituent
#    values:
#    6.1. "varE"
#         variance of potential energy per particle; INTERVAL VALUE
# 7. "nematicOrder"
#    P2 nematic order parameter computed as the highest magnitude eigenvalue of the nematic Q tensor. Main molecular
#    axes are shape-specific. Constituent values:
#    7.1. "P2"
#         nematic P2 parameter; INTERVAL VALUE
# 8. "smecticOrder ([n_x max] [n_y max] [n_z max])"
#    absolute value of smectic tau parameter (normalized by number density - 1 means maximal smectic order). The
#    wavevector of smectic order giving the maximal magnitude is chosen automatically from multiple PBC-compatible
#    values:
#    k = (k_x, k_y, k_z),
#    k_alpha = 2 pi n_alpha / L_alpha (alpha = x, y, z),
#    where L_alpha is box side length, n_alpha is an integer from the interval [-"[n_alpha max]", "[n_alpha max]"] given
#    by optional parameters (if not specified, the default interval is [-5, 5]).
#    Constituent values:
#    8.1. "tau"
#         absolute value of smectic order parameter; INTERVAL VALUE
#    8.2. "k_tau"
#         the wavevector of smetcic order parameter in the format "[n_x].[n_y].[n_z]"; NOMINAL VALUE
observables = numberDensity , inline packingFraction , compressibilityFactor

# This is the end of parameters for "gas" run. Next ones are for subsequent "liquid" and "solid" runs and have an
# identical format. The user is encouraged to run this test file to see how it works in practice.

[run.liquid]
temperature = 1
pressure = 11.5
thermalisationCycles = 250000
averagingCycles = 200000
averagingEvery = 2000
snapshotEvery = 100
packingFilename = packing_liquid.dat
wolframFilename = packing_liquid.nb
outputFilename = out.txt
densitySnapshotFilename = density_liquid.txt
observables = numberDensity , inline packingFraction , compressibilityFactor

[run.solid]
temperature = 1
pressure = 20
thermalisationCycles = 1000000
averagingCycles = 2000000
averagingEvery = 20000
snapshotEvery = 100
packingFilename = packing_solid.dat
wolframFilename = packing_solid.nb
outputFilename = out.txt
densitySnapshotFilename = density_solid.txt
observables = numberDensity , inline packingFraction , compressibilityFactor